// services/youtube-captions.ts

import axios from 'axios';
import cheerio from 'cheerio';
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import ytdl from 'ytdl-core';

const writeFileAsync = promisify(fs.writeFile);
const readFileAsync = promisify(fs.readFile);
const unlinkAsync = promisify(fs.unlink);

// Type definitions
interface ExtractionOptions {
  useAutoCaption?: boolean;
}

interface TranscriptionResult {
  transcription: string;
  language: string;
  isAutoGenerated: boolean;
}

interface CaptionTrack {
  baseUrl: string;
  languageCode: string;
  kind?: string;
  name?: string;
}

/**
 * Extract captions from a YouTube video
 * @param videoId - YouTube video ID
 * @param options - Options for extraction
 * @returns Promise with transcription result
 */
export async function extractCaptions(
  videoId: string, 
  options: ExtractionOptions = {}
): Promise<TranscriptionResult> {
  const { useAutoCaption = true } = options;
  
  // First try using ytdl-core to get caption info
  try {
    const videoInfo = await ytdl.getInfo(videoId);
    const captionTracks = videoInfo.player_response.captions?.playerCaptionsTracklistRenderer?.captionTracks as CaptionTrack[] | undefined;
    
    if (captionTracks && captionTracks.length > 0) {
      // Find appropriate caption track
      let captionTrack: CaptionTrack | undefined = undefined;
      
      if (useAutoCaption) {
        // Try to find auto-generated English captions first
        captionTrack = captionTracks.find(track => 
          track.languageCode === 'en' && track.kind === 'asr');
      }
      
      // If not found or manual captions requested, look for manual English captions
      if (!captionTrack) {
        captionTrack = captionTracks.find(track => 
          track.languageCode === 'en' && (!track.kind || track.kind !== 'asr'));
      }
      
      // If still not found, just use the first available track
      if (!captionTrack && captionTracks.length > 0) {
        captionTrack = captionTracks[0];
      }
      
      if (captionTrack && captionTrack.baseUrl) {
        const captionResponse = await axios.get(captionTrack.baseUrl);
        const transcription = parseXmlCaptions(captionResponse.data);
        
        return {
          transcription,
          language: captionTrack.languageCode,
          isAutoGenerated: captionTrack.kind === 'asr' || false
        };
      }
    }
  } catch (ytdlError) {
    console.log('ytdl-core method failed, trying alternative methods:', ytdlError instanceof Error ? ytdlError.message : 'Unknown error');
  }
  
  // If ytdl-core failed, try using youtube-dl
  try {
    return await extractWithYoutubeDl(videoId, { useAutoCaption });
  } catch (youtubeDlError) {
    console.log('youtube-dl method failed, trying scraping method:', youtubeDlError instanceof Error ? youtubeDlError.message : 'Unknown error');
    
    // If youtube-dl failed, try scraping
    try {
      return await extractWithScraping(videoId, { useAutoCaption });
    } catch (scrapingError) {
      throw new Error(`All caption extraction methods failed: ${scrapingError instanceof Error ? scrapingError.message : 'Unknown error'}`);
    }
  }
}

/**
 * Extract captions using youtube-dl
 * @param videoId - YouTube video ID
 * @param options - Options for extraction
 * @returns Promise with transcription result
 */
async function extractWithYoutubeDl(
  videoId: string, 
  options: ExtractionOptions = {}
): Promise<TranscriptionResult> {
  const { useAutoCaption = true } = options;
  const tempFilePath = path.join(__dirname, '../temp', `${videoId}_${Date.now()}.vtt`);
  
  try {
    // Create temp directory if it doesn't exist
    if (!fs.existsSync(path.join(__dirname, '../temp'))) {
      fs.mkdirSync(path.join(__dirname, '../temp'), { recursive: true });
    }
    
    // Determine which subtitle options to use
    const subtitleOption = useAutoCaption 
      ? '--write-auto-sub' 
      : '--write-sub';
    
    // Run youtube-dl command
    const command = `youtube-dl --skip-download ${subtitleOption} --sub-format vtt --sub-lang en --output "${tempFilePath.replace(/\.vtt$/, '')}" https://www.youtube.com/watch?v=${videoId}`;
    
    execSync(command, { stdio: 'pipe' });
    
    // Find the generated subtitle file
    const directory = path.dirname(tempFilePath);
    const files = fs.readdirSync(directory);
    const subtitleFile = files.find(file => 
      file.includes(videoId) && (file.endsWith('.vtt') || file.endsWith('.en.vtt'))
    );
    
    if (!subtitleFile) {
      throw new Error('Subtitle file not found after extraction');
    }
    
    const fullSubtitlePath = path.join(directory, subtitleFile);
    const fileContent = await readFileAsync(fullSubtitlePath, 'utf8');
    
    // Clean up the file
    try {
      await unlinkAsync(fullSubtitlePath);
    } catch (unlinkError) {
      console.log('Warning: Failed to delete temporary subtitle file', unlinkError);
    }
    
    // Parse VTT content
    const transcription = parseVttContent(fileContent);
    
    return {
      transcription,
      language: 'en',
      isAutoGenerated: useAutoCaption
    };
  } catch (error) {
    // Clean up temp file if it exists
    try {
      if (fs.existsSync(tempFilePath)) {
        await unlinkAsync(tempFilePath);
      }
    } catch (cleanupError) {
      console.log('Warning: Failed to clean up temporary file', cleanupError);
    }
    
    throw error;
  }
}

/**
 * Extract captions by scraping YouTube page
 * @param videoId - YouTube video ID
 * @param options - Options for extraction
 * @returns Promise with transcription result
 */
async function extractWithScraping(
  videoId: string, 
  options: ExtractionOptions = {}
): Promise<TranscriptionResult> {
  const { useAutoCaption = true } = options;
  
  try {
    const response = await axios.get(`https://www.youtube.com/watch?v=${videoId}`);
    const html = response.data;
    const $ = cheerio.load(html);
    
    // Try to find the script containing YouTube player response
    let playerResponse: any = null;
    $('script').each((i, script) => {
      const scriptContent = $(script).html() || '';
      
      if (scriptContent.includes('ytInitialPlayerResponse')) {
        try {
          const startIndex = scriptContent.indexOf('ytInitialPlayerResponse') + 'ytInitialPlayerResponse = '.length;
          const endIndex = scriptContent.indexOf('};', startIndex) + 1;
          const jsonStr = scriptContent.substring(startIndex, endIndex);
          playerResponse = JSON.parse(jsonStr);
        } catch (parseError) {
          console.log('Failed to parse player response from script tag');
        }
      }
    });
    
    if (!playerResponse) {
      throw new Error('Could not find player response in page');
    }
    
    const captionTracks = playerResponse.captions?.playerCaptionsTracklistRenderer?.captionTracks as CaptionTrack[] | undefined;
    
    if (!captionTracks || captionTracks.length === 0) {
      throw new Error('No caption tracks found');
    }
    
    // Find appropriate caption track
    let captionTrack: CaptionTrack | undefined = undefined;
    
    if (useAutoCaption) {
      // Try to find auto-generated English captions first
      captionTrack = captionTracks.find(track => 
        track.languageCode === 'en' && track.kind === 'asr');
    }
    
    // If not found or manual captions requested, look for manual English captions
    if (!captionTrack) {
      captionTrack = captionTracks.find(track => 
        track.languageCode === 'en' && (!track.kind || track.kind !== 'asr'));
    }
    
    // If still not found, just use the first available track
    if (!captionTrack && captionTracks.length > 0) {
      captionTrack = captionTracks[0];
    }
    
    if (!captionTrack || !captionTrack.baseUrl) {
      throw new Error('Could not find suitable caption track');
    }
    
    const captionResponse = await axios.get(captionTrack.baseUrl);
    const transcription = parseXmlCaptions(captionResponse.data);
    
    return {
      transcription,
      language: captionTrack.languageCode,
      isAutoGenerated: captionTrack.kind === 'asr' || false
    };
  } catch (error) {
    throw error;
  }
}

/**
 * Parse XML captions to extract text
 * @param xml - XML caption content
 * @returns Extracted transcription
 */
function parseXmlCaptions(xml: string): string {
  const textSegments: string[] = [];
  const regex = /<text[^>]*>([\s\S]*?)<\/text>/g;
  let match: RegExpExecArray | null;
  
  while ((match = regex.exec(xml)) !== null) {
    let text = match[1];
    
    // Replace HTML entities
    text = text.replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'");
    
    if (text.trim()) {
      textSegments.push(text.trim());
    }
  }
  
  return textSegments.join(' ');
}

/**
 * Parse VTT caption content to extract text
 * @param vttContent - VTT caption content
 * @returns Extracted transcription
 */
function parseVttContent(vttContent: string): string {
  // Remove VTT header and styling
  const lines = vttContent.split('\n');
  let textLines: string[] = [];
  let inCue = false;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip empty lines, timestamps and headers
    if (!line || line === 'WEBVTT' || line.includes('-->') || line.match(/^\d+$/)) {
      inCue = line.includes('-->');
      continue;
    }
    
    // If we're in a cue, this line should be text
    if (inCue && !line.startsWith('NOTE') && !line.startsWith('<')) {
      textLines.push(line);
    }
  }
  
  // Join and clean up the text
  return textLines.join(' ')
    .replace(/<[^>]*>/g, '') // Remove any HTML tags
    .replace(/\s+/g, ' ') // Replace multiple spaces with a single space
    .trim();
}